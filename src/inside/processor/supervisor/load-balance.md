# 负载均衡

Supervisor 的这套负载均衡系统既保证了每个 Worker 的工作负载都能保持在最大负载内，又通过对 Worker 的监控保证了整套系统的高可靠性。

## 前置内容

### 「被动模式」和基于事件的任务分配

Supervisor 作为 Real-Time Processor 的中心节点，管理着所有的 Worker 和任务。因此，即便是最简单的轮询操作，乘以 Worker 的个数之后也会造成不小的性能开销。为了优化性能，我们应该尽量减少 Supervisor 主动执行轮询或请求操作的次数。为了实现这一目标，Supervisor 使用「基于事件的任务分配和负载均衡」这一理念，将「任务查询」「任务分配」等程序逻辑置于事件之内，只有当任务列表发生变化的时候才会去触发相应的事件。这样的设计确保了 Supervisor 的基础性能占用维持在一个较低的水平。

### Worker 状态

因为 Worker 的目标网站都是相同的，所以「不同任务具有不同的可用性」的可能性几乎为零。因此，我们可以简单地通过一个名为 `isActive` 的布尔值来描述 Worker 的当前状态：「可用」或「不可用」。

### 连接状态

在 [通信](/inside/processor/supervisor/communication/) 一节中我们已经提到过，Supervisor 和 Worker 之间传递的所有消息都是单向的，因此二者之间不会有任何的「握手」流程，因此我们也就没有任何办法显式地判断 Supervisor 和任何一个 Worker 是否处于连接状态。因此，下文中提到的任何「连接状态」实际上都是从 Worker 的 `isActive` 值获取的。更改这个值则是使用下面将要讲述的「低精度计时器」。

### 低精度计时器

Supervisor 需要实时监视每个 Worker 的运行状态，因此需要为每一个 Worker 设定一个 Timeout，超出 Timeout 仍没有汇报状态的 Worker 就应该被判断为「不可用」（即 `isActive = false`）后由 Supervisor 进行下一步的处理（触发「任务分配」事件）。但若是为每个 Worker 设定一个 Timeout 并且在一次处理之后立刻启动下一轮 Timeout 的话就会始终有不小数量的逻辑代码属于 Timeout 的等待状态。此外，高精度的 Timeout 也会造成不小的性能开销，但是轮询请求和 Timeout 处理的精度要求却远没有这么高。因此，Supervisor 使用一个低精度的计时器来处理所有的轮询事件和 Timeout 事件。

这个低精度计时器提供两种注册方法：轮询和 Timeout，分别使用 `轮询时间` 和 `Timeout 时间` 以及另一个 `Complete 事件回调` 作为参数。`轮询时间` 仅会由「任务查询」使用，`Timeout 时间` 仅会在接收到 Worker 消息时重新设置（参见 [Income](/inside/processor/supervisor/income/)）。

## 生命周期

### 1.预热

Supervisor 在启动后即进入预热状态，等待 Worker 的连接但不分配任务。预热的时间通常在 30 秒左右。预热完成之后 Supervisor 即会开始任务查询。

::: tip 为什么需要预热？
由于每个 Worker 都会定期向 Supervisor 汇报状态和传递数据，不管 Supervisor 状态如何。因此，Supervisor 启动后所有 Worker 并不能同时连接到 Supervisor 上。这种情况下，直接监听 Worker 的连接并立即进行任务分配的做法显然是不合理的。因此，我们需要等待目前在线的全部 Worker 均成功连接之后再继续操作。
:::

### 2.任务查询

「任务查询」是一个事件，用来从 Spider 处更新任务列表。

#### Invoker

「任务查询」在以下情况下会被触发：

- Supervisor 启动时会被触发，获取任务列表并进行全部分配（同时重置 Worker 状态）。

- 每半个小时任务均会被触发，获取最新的任务列表和现有的任务列表进行比对，若有新增或减少的任务则会进行重新分配。

### 3.任务分配

「任务分配」是一个事件，使用**两个任务数组作为前两个参数**（分别为 `add` 和 `remove`），表示需要添加和减少的任务；使用另一个布尔值作为第三个参数，表示是否需要重置 Worker 的任务。接收到「任务分配」的指令后，Supervisor 即会开始任务分配流程。

#### Invoker

「任务分配」在以下情况下会被触发：

- 启动时由「任务查询」触发，分配所有任务。

- 由低精度计时器的 Timeout 触发，表示一个 Worker 已经不可用。

此时，Supervisor 会检查该 Worker 死亡前运行的任务，并将这些任务添加到 `add` 数组中。

- 定时任务触发「任务查询」后触发，使用刚刚同步的任务列表进行分配。

#### Workflow

在任务分配开始之前，我们先给所有连接的 Worker 设置一个空的「指令集」，「指令集」中的指令可以是「预先重置」、「添加任务」和「结束任务」。

- 首先，如果参数中指明需要重置 Worker 的任务，则在给 Worker 的指令中加入「预先重置」的指令。（仅用于 Supervisor 的重新启动。）

::: tip TIP
Worker 接到「预先重置」的指令之后就要先结束所有的任务吗？不一定。Worker 可以在接收到「预先重置」的指令之后与传来的新的任务做差集，然后结束不再需要的任务。
:::

- 然后，Supervisor 遍历所有的 Worker，找出 `remove` 数组中指示的任务后将「结束任务」的指令添加到 提供给相关 Worker 的指令中，并从相关 Worker 的 `正在运行的任务数` 中减去相应的任务个数。

- 然后，Supervisor 会获取所有 Worker 的状态，通过每个 Worker 的 `可新增任务数` 推算出每个 Worker 的权重。`可新增任务数` 由 `最大负载 - 正在运行的任务数` 计算得到。其中，`最大负载` 是由 Worker 提供的。

- 接着，Supervisor 使用**总的任务数乘以连接数（参见 [通信](/inside/processor/supervisor/communication/)，一般为 2-3）再乘以权重后向上取整**，得出每个 Worker 需要增加的任务数。

- 最后，Supervisor 为每个 Worker 从 `add` 数组中取出一定量的任务加入该 Worker 的「添加任务」的指令集中并发送所有的指令。

### 4.完成

此时，Supervisor 的各个事件已经开始监听，低精度计时器开始运行，Supervisor 进入正常运行状态，等待触发事件。

::: tip 基于事件的任务分配
在「基于事件的任务分配」设计下，如果 Supervisor 没有在处理事件的话，正常运行的逻辑只有低精度计时器，这保证了 Supervisor 对内存的最低占用。
:::
