# 负载均衡

Supervisor 的这套负载均衡系统既保证了每个 Worker 的工作负载都能保持在最大负载内，又通过对 Worker 的监控保证了整套系统的高可靠性。

## 前置内容

### 「被动模式」和基于事件的任务分配

Supervisor 作为 Real-Time Processor 的中心节点，管理着所有的 Worker 和任务。因此，即便是最简单的轮询操作，乘以 Worker 的与每个 Worker 的任务个数之后也会造成不小的性能开销。为了优化性能，我们应该尽量减少 Supervisor 主动执行轮询或请求操作的次数。为了实现这一目标，Supervisor 使用「基于事件的任务分配和负载均衡」这一理念，将「任务查询」「任务分配」等程序逻辑置于事件之内，只有当任务列表发生变化的时候才会去触发相应的事件。这样的设计确保了 Supervisor 的基础性能占用维持在一个较低的水平。

### 定义

- 任务：一个 Worker 上保持的对一个 Bilibili 直播间的会话。此“任务”应该被视为一种长期运行的任务。也就是说，一个 Worker 会同时持有多个任务，一个房间也会被多个任务同时监听。

### Worker 状态

基于一个事实：在 Bilibili 直播协议中，一个房间在 30s 内必定会传输至少一个数据包（最少情况下为心跳回复包）。因此，如果一个任务在 30s 内无任何数据上报，可以视为该任务连接中断。Supervisor 将会 Unassign 该任务，并删除该任务的信息，产生一个任务空缺。

同样，如果一个 Worker 在 30s 内无任何数据上报，可视为该 Worker 连接中断。Supervisor 将会断开该 Worker 的连接，并删除所有与该 Worker 关联的任务信息，产生与 Worker 关联的任务相等数量的任务空缺。

### 连接状态

在 [通信](/inside/processor/supervisor/communication/) 一节中我们已经提到过，Supervisor 和 Worker 之间传递的所有消息都是单向的，因此二者之间不会有任何的「握手」流程，因此我们也就没有任何办法显式地判断 Supervisor 和任何一个 Worker 是否处于连接状态。因此，下文中提到的任何「连接状态」实际上都是从 Worker 状态获取的。更改这个值则是使用下面将要讲述的「低精度计时器」。

### 低精度计时器

Supervisor 需要实时监视每个 Worker 的运行状态，因此需要为每一个 Worker 设定一个 Timeout，超出 Timeout 仍没有汇报状态的 Worker 就应该被判断为「不可用」（即 `isActive = false`）后由 Supervisor 进行下一步的处理（触发「任务分配」事件）。但若是为每个 Worker 设定一个 Timeout 并且在一次处理之后立刻启动下一轮 Timeout 的话就会始终有不小数量的逻辑代码属于 Timeout 的等待状态。此外，高精度的 Timeout 也会造成不小的性能开销，但是轮询请求和 Timeout 处理的精度要求却远没有这么高。因此，Supervisor 使用一个低精度的计时器来处理所有的轮询事件和 Timeout 事件。

这个低精度计时器提供两种注册方法：轮询和 Timeout，分别使用 `轮询时间` 和 `Timeout 时间` 以及另一个 `Complete 事件回调` 作为参数。`轮询时间` 仅会由「任务查询」使用，`Timeout 时间` 仅会在接收到 Worker 消息时重新设置（参见 [Income](/inside/processor/supervisor/income/)）。

## 生命周期

### 1.预热

Supervisor 在启动后即进入预热状态，等待 Worker 的连接但不分配任务。预热的时间通常在 30 秒左右。预热完成之后 Supervisor 即会开始任务查询。

::: tip 为什么需要预热？
由于每个 Worker 都会定期向 Supervisor 汇报状态和传递数据，不管 Supervisor 状态如何。因此，Supervisor 启动后所有 Worker 并不能同时连接到 Supervisor 上。这种情况下，直接监听 Worker 的连接并立即进行任务分配的做法显然是不合理的。因此，我们需要等待目前在线的全部 Worker 均成功连接之后再继续操作。
:::

### 2.任务查询

「任务查询」是一个事件，用来从 Spider 处更新任务列表。

#### Invoker

「任务查询」在以下情况下会被触发：

- Supervisor 启动时会被触发，获取任务列表并进行全部分配（同时重置 Worker 状态）。

- 每半个小时任务均会被触发，获取最新的任务列表和现有的任务列表进行比对，若有新增或减少的任务则会进行重新分配。

### 3.任务分配

「任务分配」是一个事件，使用**两个任务数组作为前两个参数**（分别为 `add` 和 `remove`），表示需要添加和减少的任务；使用另一个布尔值作为第三个参数，表示是否需要重置 Worker 的任务。接收到「任务分配」的指令后，Supervisor 即会开始任务分配流程。

#### Invoker

「任务分配」在以下情况下会被触发：

- 启动时由「任务查询」触发，分配所有任务。

- 由低精度计时器的 Timeout 触发，表示一个 Worker 已经不可用。

此时，Supervisor 会检查该 Worker 死亡前运行的任务，并将这些任务添加到 `add` 数组中。

- 定时任务触发「任务查询」后触发，使用刚刚同步的任务列表进行分配。

#### Workflow

在任务分配开始之前，我们先给所有连接的 Worker 设置一个空的「指令集」，「指令集」中的指令可以是「预先重置」、「添加任务」和「结束任务」。

- 首先，如果参数中指明需要重置 Worker 的任务，则在给 Worker 的指令中加入「预先重置」的指令。（仅用于 Supervisor 的重新启动。）

::: tip TIP
Worker 接到「预先重置」的指令之后就要先结束所有的任务吗？不一定。Worker 可以在接收到「预先重置」的指令之后与传来的新的任务做差集，然后结束不再需要的任务。
:::

- 然后，Supervisor 遍历所有的 Worker，找出 `remove` 数组中指示的任务后将「结束任务」的指令添加到提供给相关 Worker 的指令中，并从相关 Worker 的 `正在运行的任务数` 中减去相应的任务个数。

- 然后，Supervisor 会获取所有 Worker 的状态，通过每个 Worker 的 `可新增任务数` 推算出每个 Worker 的权重。`可新增任务数` 由 `最大负载 - 正在运行的任务数` 计算得到。其中，`最大负载` 是由 Worker 提供的。

- 接着，Supervisor 使用**总的任务数乘以连接数（参见 [通信](/inside/processor/supervisor/communication/)，一般为 2-3）再乘以权重后向上取整**，得出每个 Worker 需要增加的任务数。

- 最后，Supervisor 为每个 Worker 从 `add` 数组中取出一定量的任务加入该 Worker 的「添加任务」的指令集中并发送所有的指令。若 `add` 数组为空即结束分配。

### 4.完成

此时，Supervisor 的各个事件已经开始监听，低精度计时器开始运行，Supervisor 进入正常运行状态。此时 Supervisor 会开始从各个 Worker 接收有效荷载，执行去重并发送至 RabbitMQ，以传输至下游应用。

